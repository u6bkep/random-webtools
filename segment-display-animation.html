<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Segment Display</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        .display-container {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="display-container">
        <svg viewBox="0 0 160 240" width="300" height="450" id="segmentDisplay">
            <!-- Background with rounded corners - now black -->
            <rect
                x="10"
                y="10"
                width="140"
                height="220"
                rx="35"
                ry="35"
                fill="#000000"
                stroke="#000000"
                stroke-width="2"
            />
            
            <!-- Inner area -->
            <rect
                x="25"
                y="25"
                width="110"
                height="190"
                rx="20"
                ry="20"
                fill="#000000"
                stroke="#000000"
                stroke-width="1"
            />
            
            <!-- Grid segments will be inserted here by JavaScript -->
            
            <!-- Outer ring progress indicator - now blue -->
            <path
                id="ringPath"
                fill="none"
                stroke="#0066ff"
                stroke-width="8"
                stroke-linecap="round"
                stroke-linejoin="round"
            />
        </svg>
    </div>

    <script>
        // Define the digit patterns (which segments to light up for each number)
        const digitPatterns = {
            0: [
                [1, 1, 1],
                [1, 0, 1],
                [1, 0, 1],
                [1, 0, 1],
                [1, 1, 1]
            ],
            1: [
                [0, 0, 1],
                [0, 0, 1],
                [0, 0, 1],
                [0, 0, 1],
                [0, 0, 1]
            ],
            2: [
                [1, 1, 1],
                [0, 0, 1],
                [1, 1, 1],
                [1, 0, 0],
                [1, 1, 1]
            ],
            3: [
                [1, 1, 1],
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 1],
                [1, 1, 1]
            ],
            4: [
                [1, 0, 1],
                [1, 0, 1],
                [1, 1, 1],
                [0, 0, 1],
                [0, 0, 1]
            ],
            5: [
                [1, 1, 1],
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 1],
                [1, 1, 1]
            ],
            6: [
                [1, 1, 1],
                [1, 0, 0],
                [1, 1, 1],
                [1, 0, 1],
                [1, 1, 1]
            ],
            7: [
                [1, 1, 1],
                [0, 0, 1],
                [0, 0, 1],
                [0, 0, 1],
                [0, 0, 1]
            ],
            8: [
                [1, 1, 1],
                [1, 0, 1],
                [1, 1, 1],
                [1, 0, 1],
                [1, 1, 1]
            ],
            9: [
                [1, 1, 1],
                [1, 0, 1],
                [1, 1, 1],
                [0, 0, 1],
                [1, 1, 1]
            ]
        };

        let count = 0;
        let progress = 0;
        let segmentElements = [];

        // Create the grid segments
        function createGridSegments() {
            const svg = document.getElementById('segmentDisplay');
            
            for (let row = 0; row < 5; row++) {
                segmentElements[row] = [];
                for (let col = 0; col < 3; col++) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', 40 + col * 30);
                    rect.setAttribute('y', 40 + row * 35);
                    rect.setAttribute('width', '20');
                    rect.setAttribute('height', '20');
                    rect.setAttribute('fill', '#111111');
                    rect.setAttribute('stroke', '#000000');
                    rect.setAttribute('stroke-width', '1');
                    
                    svg.appendChild(rect);
                    segmentElements[row][col] = rect;
                }
            }
        }

        // Get the path for the outer ring based on progress
        function getRingPath() {
            // Parameters based on your SVG structure
            const width = 160;
            const height = 240;
            const borderRadius = 35;
            
            // Calculate path parameters
            const cx = width / 2;
            const cy = height / 2;
            const w = width - 20;
            const h = height - 20;
            
            // Create path that follows the rounded rectangle shape
            // Start at top center and go clockwise
            const startX = cx;
            const startY = 10;
            
            // Calculate how much of the perimeter to fill based on progress
            const totalPerimeter = 2 * (w + h - 2 * borderRadius) + 2 * Math.PI * borderRadius;
            const fillLength = totalPerimeter * progress;
            
            // Create a clipping path for the outer ring
            let clipPath = '';
            
            if (progress === 0) {
                // Just return a tiny bit at the start point to avoid empty path
                return `M ${startX},${startY} l 0.1,0`;
            } else if (progress === 1) {
                // Full ring
                clipPath = `
                    M ${startX},${startY}
                    h ${(w/2) - borderRadius}
                    a ${borderRadius},${borderRadius} 0 0 1 ${borderRadius},${borderRadius}
                    v ${h - 2 * borderRadius}
                    a ${borderRadius},${borderRadius} 0 0 1 -${borderRadius},${borderRadius}
                    h -${w - 2 * borderRadius}
                    a ${borderRadius},${borderRadius} 0 0 1 -${borderRadius},-${borderRadius}
                    v -${h - 2 * borderRadius}
                    a ${borderRadius},${borderRadius} 0 0 1 ${borderRadius},-${borderRadius}
                    h ${(w/2) - borderRadius}
                `;
            } else {
                // Partial ring - we need to calculate where to stop
                let remainingLength = fillLength;
                
                // Top edge (from center to right)
                const topRight = (w/2 - borderRadius);
                if (remainingLength <= topRight) {
                    return `M ${startX},${startY} h ${remainingLength}`;
                }
                remainingLength -= topRight;
                clipPath = `M ${startX},${startY} h ${topRight}`;
                
                // Top-right corner
                const cornerArc = Math.PI/2 * borderRadius;
                if (remainingLength <= cornerArc) {
                    const angle = remainingLength / borderRadius;
                    return `${clipPath} a ${borderRadius},${borderRadius} 0 0 1 ${borderRadius * Math.sin(angle)},${borderRadius * (1 - Math.cos(angle))}`;
                }
                remainingLength -= cornerArc;
                clipPath += ` a ${borderRadius},${borderRadius} 0 0 1 ${borderRadius},${borderRadius}`;
                
                // Right edge
                const rightEdge = h - 2 * borderRadius;
                if (remainingLength <= rightEdge) {
                    return `${clipPath} v ${remainingLength}`;
                }
                remainingLength -= rightEdge;
                clipPath += ` v ${rightEdge}`;
                
                // Bottom-right corner
                if (remainingLength <= cornerArc) {
                    const angle = remainingLength / borderRadius;
                    return `${clipPath} a ${borderRadius},${borderRadius} 0 0 1 ${-borderRadius * (1 - Math.cos(angle))},${borderRadius * Math.sin(angle)}`;
                }
                remainingLength -= cornerArc;
                clipPath += ` a ${borderRadius},${borderRadius} 0 0 1 -${borderRadius},${borderRadius}`;
                
                // Bottom edge
                const bottomEdge = w - 2 * borderRadius;
                if (remainingLength <= bottomEdge) {
                    return `${clipPath} h -${remainingLength}`;
                }
                remainingLength -= bottomEdge;
                clipPath += ` h -${bottomEdge}`;
                
                // Bottom-left corner
                if (remainingLength <= cornerArc) {
                    const angle = remainingLength / borderRadius;
                    return `${clipPath} a ${borderRadius},${borderRadius} 0 0 1 -${borderRadius * Math.sin(angle)},-${borderRadius * (1 - Math.cos(angle))}`;
                }
                remainingLength -= cornerArc;
                clipPath += ` a ${borderRadius},${borderRadius} 0 0 1 -${borderRadius},-${borderRadius}`;
                
                // Left edge
                const leftEdge = h - 2 * borderRadius;
                if (remainingLength <= leftEdge) {
                    return `${clipPath} v -${remainingLength}`;
                }
                remainingLength -= leftEdge;
                clipPath += ` v -${leftEdge}`;
                
                // Top-left corner
                if (remainingLength <= cornerArc) {
                    const angle = remainingLength / borderRadius;
                    return `${clipPath} a ${borderRadius},${borderRadius} 0 0 1 ${borderRadius * (1 - Math.cos(angle))},-${borderRadius * Math.sin(angle)}`;
                }
                remainingLength -= cornerArc;
                clipPath += ` a ${borderRadius},${borderRadius} 0 0 1 ${borderRadius},-${borderRadius}`;
                
                // Remaining of top edge (to center)
                if (remainingLength <= topRight) {
                    return `${clipPath} h ${remainingLength}`;
                }
                clipPath += ` h ${topRight}`;
            }
            
            return clipPath;
        }

        // Update the display
        function updateDisplay() {
            // Update grid segments
            const pattern = digitPatterns[count];
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 3; col++) {
                    const color = pattern[row][col] ? '#0066ff' : '#111111';
                    segmentElements[row][col].setAttribute('fill', color);
                }
            }

            // Update ring
            const ringPath = document.getElementById('ringPath');
            ringPath.setAttribute('d', getRingPath());
        }

        // Animation loop
        function animate() {
            count = (count + 1) % 10;
            progress = count / 9; // Set progress as percentage of 0-9
            updateDisplay();
        }

        // Initialize the display
        function init() {
            createGridSegments();
            updateDisplay();
            
            // Start animation
            setInterval(animate, 1000);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>